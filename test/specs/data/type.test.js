import test from 'ava';
import ObjectFixture from '../../fixtures/object.fixture';
import type from '../../../lib/data/type';

test('lib/data/typeOf', t => {
	t.is(toString.call(type.typeOf), '[object Function]');
	t.is(type.typeOf((() => arguments)()), 'Arguments');
	t.is(type.typeOf(arguments), 'Arguments');
	t.is(type.typeOf('ab'), 'String');
	t.is(type.typeOf(new String('foo')), 'String');
	t.is(type.typeOf(/^./g), 'RegExp');
	t.is(type.typeOf(new RegExp('foo')), 'RegExp');
	t.is(type.typeOf(10000), 'Number');
	t.is(type.typeOf(new Number(42)), 'Number');
	t.is(type.typeOf({name: 1}), 'Object');
	t.is(type.typeOf({}), 'Object');
	t.is(type.typeOf(Object.create(null)), 'Object');
	t.is(type.typeOf(new ObjectFixture()), 'ObjectFixture');
	t.is(type.typeOf([]), 'Array');
	t.is(type.typeOf([1, 2]), 'Array');
	t.is(type.typeOf(new Array()), 'Array');
	t.is(type.typeOf(true), 'Boolean');
	t.is(type.typeOf(false), 'Boolean');
	t.is(type.typeOf(new Boolean(true)), 'Boolean');
	t.is(type.typeOf(null), 'Null');
	t.is(type.typeOf(undefined), 'Undefined');
	t.is(type.typeOf(Symbol), 'Function');
	t.is(type.typeOf(Symbol('bar')), 'Symbol');
	t.is(type.typeOf(String), 'Function');
	t.is(type.typeOf(Boolean), 'Function');
	t.is(type.typeOf(Number), 'Function');
	t.is(type.typeOf(RegExp), 'Function');
	t.is(type.typeOf(TypeError), 'Function');
	t.is(type.typeOf(Error), 'Function');
	t.is(type.typeOf(Object), 'Function');
	t.is(type.typeOf(Array), 'Function');
	t.is(type.typeOf(Boolean), 'Function');
	t.is(type.typeOf(Date), 'Function');
	t.is(type.typeOf(ObjectFixture), 'Function');
	t.is(type.typeOf(function () {}), 'Function');
	t.is(type.typeOf(new Function()), 'Function');
	t.is(type.typeOf(function * () {}), 'GeneratorFunction');
	t.is(type.typeOf(new Map()), 'Map');
	t.is(type.typeOf(new WeakMap()), 'WeakMap');
	t.is(type.typeOf(new Set()), 'Set');
	t.is(type.typeOf(new WeakSet()), 'WeakSet');
	t.is(type.typeOf(new Int8Array()), 'Int8Array');
	t.is(type.typeOf(new Uint8Array()), 'Uint8Array');
	t.is(type.typeOf(new Uint8ClampedArray()), 'Uint8ClampedArray');
	t.is(type.typeOf(new Int16Array()), 'Int16Array');
	t.is(type.typeOf(new Uint16Array()), 'Uint16Array');
	t.is(type.typeOf(new Int32Array()), 'Int32Array');
	t.is(type.typeOf(new Uint32Array()), 'Uint32Array');
	t.is(type.typeOf(new Float32Array()), 'Float32Array');
	t.is(type.typeOf(new Float64Array()), 'Float64Array');
	t.is(type.typeOf(new Date()), 'Date');
	t.is(type.typeOf(ArrayBuffer), 'Function');
	t.is(type.typeOf(new ArrayBuffer(4)), 'ArrayBuffer');
	t.is(type.typeOf(Buffer), 'Function');
	t.is(type.typeOf(new Buffer(3)), 'Buffer');

});

test('lib/data/type.writeNameFromType', t => {
	t.is(toString.call(type.writeNameFromType), '[object Function]');
	t.is(type.writeNameFromType((() => arguments)()), 'Arguments');
	t.is(type.writeNameFromType(Symbol), 'Symbol');
	t.is(type.writeNameFromType(String), 'String');
	t.is(type.writeNameFromType(RegExp), 'RegExp');
	t.is(type.writeNameFromType(Number), 'Number');
	t.is(type.writeNameFromType(TypeError), 'TypeError');
	t.is(type.writeNameFromType(Error), 'Error');
	t.is(type.writeNameFromType(Object), 'Object');
	t.is(type.writeNameFromType(Array), 'Array');
	t.is(type.writeNameFromType(Boolean), 'Boolean');
	t.is(type.writeNameFromType(Date), 'Date');
	t.is(type.writeNameFromType(null), 'Null');
	t.is(type.writeNameFromType(undefined), 'Undefined');
	t.is(type.writeNameFromType(NaN), 'Number');
	t.is(type.writeNameFromType('ab|ba', true), 'ab|ba');
	t.is(type.writeNameFromType('ab|ba'), 'String');
	t.is(type.writeNameFromType(new ObjectFixture('FixtureTest')), 'FixtureTest');
	t.is(type.writeNameFromType(ObjectFixture), 'FixtureTest');
	t.is(type.writeNameFromType([1, 2]), 'Array');
	t.is(type.writeNameFromType(/^./g), 'RegExp');
	t.is(type.writeNameFromType(10000), 'Number');
	t.is(type.writeNameFromType({name: 1}), 'Object');
	t.is(type.writeNameFromType(false), 'Boolean');
	t.is(type.writeNameFromType(new Date()), 'Date');
	t.is(type.writeNameFromType(ArrayBuffer), 'ArrayBuffer');
	t.is(type.writeNameFromType(new ArrayBuffer(4)), 'ArrayBuffer');
	t.is(type.writeNameFromType(new Int32Array(new ArrayBuffer(8))), 'Int32Array');
	t.is(type.writeNameFromType(Buffer), 'Buffer');
	t.is(type.writeNameFromType(new Buffer('ab')), 'Buffer');
});

test('lib/data/type.typify', t => {
	t.is(toString.call(type.typify), '[object Function]');
	t.is(type.typify('Arguments', (() => arguments)()), 'Arguments');
	t.is(type.typify([Symbol, String, Function, Object, Boolean]), 'Symbol|String|Function|Object|Boolean');
	t.is(type.typify([Symbol, String, Function, Object, Boolean,]), 'Symbol|String|Function|Object|Boolean'); // should be 'Symbol|String|Function|Object|Boolean|Undefined'?
	t.is(type.typify('Symbol|String|Function|Object|Boolean', true), 'Symbol|String|Function|Object|Boolean');
	t.is(type.typify([1, 'Custom', {}]), 'Number|Custom|Object'); // <- should it be an array?
	t.is(type.typify([]), 'Array');
	t.is(type.typify(1), 'Number');
	t.is(type.typify('Custom', true), 'Custom');
	t.is(type.typify({}), 'Object');
	t.is(type.typify({name: 1}), 'Object');
	t.is(type.typify(/^./g), 'RegExp');
	t.is(type.typify(false), 'Boolean');
	t.is(type.typify(new Date()), 'Date');
	t.is(type.typify(Date), 'Date');
	t.is(type.typify(ArrayBuffer), 'ArrayBuffer');
	t.is(type.typify(new ArrayBuffer(4)), 'ArrayBuffer');
	t.is(type.typify(Buffer), 'Buffer');
	t.is(type.typify(new Buffer('ab')), 'Buffer');
});

test('lib/data/type.constructorNameOf', t => {
	t.is(toString.call(type.constructorNameOf), '[object Function]');
	t.is(type.constructorNameOf((() => arguments)()), 'Arguments');
	t.is(type.constructorNameOf(() => 'foo'), 'Function');
	t.is(type.constructorNameOf(function(){return 'foo';}), 'Function');
	t.is(type.constructorNameOf(Symbol), 'Symbol');
	t.is(type.constructorNameOf(Symbol.name), 'String');
	t.is(type.constructorNameOf(String), 'String');
	t.is(type.constructorNameOf(String.name), 'String');
	t.is(type.constructorNameOf(RegExp), 'RegExp');
	t.is(type.constructorNameOf(RegExp.name), 'String');
	t.is(type.constructorNameOf(Number), 'Number');
	t.is(type.constructorNameOf(Number.name), 'String');
	t.is(type.constructorNameOf(TypeError), 'TypeError');
	t.is(type.constructorNameOf(TypeError.name), 'String');
	t.is(type.constructorNameOf(Error), 'Error');
	t.is(type.constructorNameOf(Error.name), 'String');
	t.is(type.constructorNameOf(Object), 'Object');
	t.is(type.constructorNameOf(Object.name), 'String');
	t.is(type.constructorNameOf(Array), 'Array');
	t.is(type.constructorNameOf(Array.name), 'String');
	t.is(type.constructorNameOf(Boolean), 'Boolean');
	t.is(type.constructorNameOf(Boolean.name), 'String');
	t.is(type.constructorNameOf(Date), 'Date');
	t.is(type.constructorNameOf(Date.name), 'String');
	t.is(type.constructorNameOf(null), 'Null');
	t.is(type.constructorNameOf(undefined), 'Undefined');
	t.is(type.constructorNameOf(Infinity), 'Number');
	t.is(type.constructorNameOf(NaN), 'Number');
	t.is(type.constructorNameOf(NaN.name), 'Undefined');
	t.is(type.constructorNameOf('ab|ba'), 'String');
	t.is(type.constructorNameOf(new ObjectFixture()), 'ObjectFixture');
	t.is(type.constructorNameOf(ObjectFixture), 'ObjectFixture');
	t.is(type.constructorNameOf(ObjectFixture.name), 'String');
	t.is(type.constructorNameOf([1, 2]), 'Array');
	t.is(type.constructorNameOf(/^./g), 'RegExp');
	t.is(type.constructorNameOf(10000), 'Number');
	t.is(type.constructorNameOf({name: 1}), 'Object');
	t.is(type.constructorNameOf(false), 'Boolean');
	t.is(type.constructorNameOf(new Date()), 'Date');
	t.is(type.constructorNameOf(ArrayBuffer), 'ArrayBuffer');
	t.is(type.constructorNameOf(Buffer), 'Buffer');
	t.is(type.constructorNameOf(Buffer.name), 'String');
	t.is(type.constructorNameOf(new Buffer('ab')), 'Buffer');
});

test('lib/data/type.constructorOf', t => {
	t.is(toString.call(type.constructorOf), '[object Function]');
	t.is(type.constructorOf((() => arguments)()), Object);
	t.is(type.constructorOf(() => 'foo'), Function);
	t.is(type.constructorOf(function(){}), Function);
	t.is(type.constructorOf(Symbol('foo')), Symbol);
	t.is(type.constructorOf(new String()), String);
	t.is(type.constructorOf(new RegExp('^foo')), RegExp);
	t.is(type.constructorOf(/^./g), RegExp);
	t.is(type.constructorOf(new TypeError('foo')), TypeError);
	t.is(type.constructorOf(new Error('foo')), Error);
	t.is(type.constructorOf(new Object()), Object);
	t.is(type.constructorOf({name: 1}), Object);
	t.is(type.constructorOf(new Array()), Array);
	t.is(type.constructorOf([1, 2]), Array);
	t.is(type.constructorOf(new Boolean()), Boolean);
	t.is(type.constructorOf(new Date()), Date);
	t.is(type.constructorOf(null), null);
	t.is(type.constructorOf(undefined), undefined);
	t.is(type.constructorOf(Infinity), Number);
	t.is(type.constructorOf(NaN), Number);
	t.is(type.constructorOf(10000), Number);
	t.is(type.constructorOf('ab|ba'), String);
	t.is(type.constructorOf(Object.create(null)), Object);
	t.is(type.constructorOf(new ObjectFixture('FF')), ObjectFixture);
	t.is(type.constructorOf(ObjectFixture), Function);
	t.is(type.constructorOf(false), Boolean);
	t.is(type.constructorOf(new Uint8Array()), Uint8Array);
	t.is(type.constructorOf(new Int32Array(new ArrayBuffer(8))), Int32Array);
	t.is(type.constructorOf(new ArrayBuffer(3)), ArrayBuffer);
	t.is(type.constructorOf(ArrayBuffer), Function);
	t.is(type.constructorOf(Buffer), Function);
	t.is(type.constructorOf(new Buffer('1234')), Buffer);
});

test('lib/data/type.as', t => {
	const getFoo = function(){return 'foo';};
	t.is(toString.call(type.as), '[object Function]');
	t.is(type.as([Number, Function], getFoo), getFoo);
	t.is(type.as(Number, getFoo), undefined);
	t.is(type.as(String, getFoo), 'foo');
	t.is(type.as(Number, () => 'foo'), undefined);
	t.is(type.as(String, () => 'foo'), 'foo');
	t.is(type.as(String, () => ''), '');
	t.is(type.as(Number, 'foo'), undefined);
	t.is(type.as(String, 'foo'), 'foo');
	t.is(type.as(String, ''), '');
});

test('lib/data/type.is.buffer', t => {
	t.is(toString.call(type.is.buffer), '[object Function]');
	t.is(type.is.buffer(new Uint8Array(1)), false);
	t.is(type.is.buffer(new Buffer(1)), true);
});

test('lib/data/type.is.not.buffer', t => {
	t.is(toString.call(type.is.not.buffer), '[object Function]');
	t.is(type.is.not.buffer(new Uint8Array(1)), true);
	t.is(type.is.not.buffer(new Buffer(1)), false);
});

test('lib/data/type.is', t => {
	t.is(toString.call(type.is), '[object Function]');
	t.is(type.is('Arguments', (() => arguments)()), true);
	t.is(type.is('Function|Array|Number', Infinity), true);
	t.is(type.is('Function|Array|Infinity', String), true);
	t.is(type.is('Function|Array', String), true);
	t.is(type.is('Function|Array', []), true);
	t.is(type.is('Function|Array', () => []), true);
	t.is(type.is('String|Function', 'pirate'), true);
	t.is(type.is([String, Function, Object, Infinity], Infinity), true);
	t.is(type.is([String, Function, Object, Infinity], Number), true);
	t.is(type.is([String, Function, Object, Infinity], 0), true);
	t.is(type.is([String, Function, Object, Boolean], 'pirate'), true);
	t.is(type.is([String.name, Function.name], 'pirate'), true);
	t.is(type.is('String|Function', () => 'pirate'), true);
	t.is(type.is([String, Function], () => 'pirate'), true);
	t.is(type.is([String.name, Function.name], () => 'pirate'), true);
	t.is(type.is('Function', () => 'pirate'), true);
	t.is(type.is(Function, () => 'pirate'), true);
	t.is(type.is(Function.name, () => 'pirate'), true);
	t.is(type.is('String', () => 'pirate'), false);
	t.is(type.is(String, () => 'pirate'), false);
	t.is(type.is(String.name, () => 'pirate'), false);
	t.is(type.is(ObjectFixture, new ObjectFixture('pirate')), true);
	t.is(type.is(ObjectFixture.name, new ObjectFixture('pirate')), true);
	t.is(type.is('Pirate', new ObjectFixture('Pirate')), true);
	t.is(type.is(undefined, undefined), true);
	t.is(type.is('undefined', undefined, true), true);
	t.is(type.is('Undefined', undefined), true);
	t.is(type.is(null, null), true);
	t.is(type.is('null', null, true), true);
	t.is(type.is('Null', null), true);
	t.is(type.is(NaN, NaN), true);
	t.is(type.is(Number, NaN), true);
	t.is(type.is(Number.name, NaN), true);
	t.is(type.is('Number', NaN), true);
	t.is(type.is(Buffer, new Uint8Array(1)), false);
});

test('lib/data/type.is.not', t => {
	t.is(toString.call(type.is.not), '[object Function]');
	t.is(type.is.not('Arguments', (() => arguments)()), false);
	t.is(type.is.not('Function|Array|Number', String), false);
	t.is(type.is.not('Function|Array|Number', Infinity), false);
	t.is(type.is.not('Function|Array', String), false);
	t.is(type.is.not('Function|Array', []), false);
	t.is(type.is.not('Function|Array', () => []), false);
	t.is(type.is.not('String|Function', 'pirate'), false);
	t.is(type.is.not([String, Function, Object, Boolean], 'pirate'), false);
	t.is(type.is.not([String, Function, Object, Infinity], Infinity), false);
	t.is(type.is.not([String, Function, Object, Infinity], Number), false);
	t.is(type.is.not([String, Function, Object, Infinity], 0), false);
	t.is(type.is.not([String.name, Function.name], 'pirate'), false);
	t.is(type.is.not('String|Function', () => 'pirate'), false);
	t.is(type.is.not([String, Function], () => 'pirate'), false);
	t.is(type.is.not([String.name, Function.name], () => 'pirate'), false);
	t.is(type.is.not('Function', () => 'pirate'), false);
	t.is(type.is.not(Function, () => 'pirate'), false);
	t.is(type.is.not(Function.name, () => 'pirate'), false);
	t.is(type.is.not('String', () => 'pirate'), true);
	t.is(type.is.not(String, () => 'pirate'), true);
	t.is(type.is.not(String.name, () => 'pirate'), true);
	t.is(type.is.not(ObjectFixture, new ObjectFixture('pirate')), false);
	t.is(type.is.not(ObjectFixture.name, new ObjectFixture('pirate')), false);
	t.is(type.is.not('ObjectFixture', new ObjectFixture()), false);
	t.is(type.is.not(undefined, undefined), false);
	t.is(type.is.not('undefined', undefined, true), false);
	t.is(type.is.not('Undefined', undefined), false);
	t.is(type.is.not(null, null), false);
	t.is(type.is.not('null', null, true), false);
	t.is(type.is.not('Null', null), false);
	t.is(type.is.not(Infinity, Infinity), false);
	t.is(type.is.not(Infinity, Number), true);
	t.is(type.is.not(Number, Infinity), false);
	t.is(type.is.not(NaN, NaN), false);
	t.is(type.is.not(Number, NaN), false);
	t.is(type.is.not(Number.name, NaN), false);
	t.is(type.is.not('Number', NaN), false);
	t.is(type.is.not(Uint8Array, new Buffer(0)), true);
});
